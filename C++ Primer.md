# C++ Primer

# 0 引言

## 0.0 摘要

C++由三部分组成：

+ 低级语言（继承自C语言）
+ 现代高级语言特性（允许定义自己的类型以及组织大规模程序和系统）
+ 标准库（利用高级特性来提供有用的数据结构和算法）

书籍安排：

+ I II部分介绍C++语言和标准库的基本内容，通过使用标准库中定义的抽象设施让我们更加适应高级程序设计技术。
+ III IV部分介绍类的抽象形式和大型程序需要的语言特性

程序源码：

[书籍例程源码](https://www.informit.com/store/c-plus-plus-primer-9780321714114)



# 1 开始

## 1.1 编写一个简单的C++程序

每个C++程序都包含一个或者多个函数，其中一个必须命名为main。

main函数的返回类型必须是int，int类型是语言的一种内置类型。

```c++
int main(){
    return 0;
}
```

一个函数包括：return type, function name, parameter list, function body.

**重点概念：类型**

一种类型不仅定义了数据元素的内容，也定义了这类数据上可以进行的运算。

### 1.1.1 编译、运行程序

如何编译程序依赖于操作系统和编译器，很多PC机上具备集成开发环境IDE，将编译器和其他程序创建的和分析工具包装在一起。

大多数编译器要求程序源码存储在一个或者多个文件中，程序文件通常被称为源文件。不同编译器使用不同后缀命名约定，常见.cc .css .cpp .c。

运行cpp文件最常用的编译器是GNU和微软VS编译器，运行gnn编译器：

```shell
g++ -o prog1 prog1.cc
```

运行微软VS编译器

```shell
c1 /EHsc prog1.cpp
```

分别会生成prog1.out 和prog1.exe两个不同OS下的可执行文件。

返回值-1常被看作程序错误的标识。

## 1.2 初始输入输出

C++语言没有定义任何输入输出语句，但他包含了一个全面的**标准库**来提供IO机制和其他的设施。对于很多用途，我们只需要了解IO库中一部分基本概念和操作。

iostream库包含了两个基础类型istream和ostream：输入流和输出流。一个流是一个字符序列，从IO设备读出or写入IO设备。

**标准输入输出对象**

标准库有4个IO对象

+ cin：标准输入 

+ cout：标准输出

+ cerr：输出警告和错误信息（标准错误）

+ clog：输出程序运行的一般信息

```c++
std::cout << "Enter two numbers:" <<std::endl;
```

<<：输出运算符，左侧对象ostream对象，右侧对象要打印的值

前一半是字符串字面值常量string literal，输出Enter two numbers;

后一半是操纵符特殊值，写入endl的效果是结束当前行，并将设备环链的缓冲区（buffer）中的内容刷到设备中。缓存刷新操作可以保证目前为止程序产生的所有输出都真正写到输出流中，不需要停留在内存中等待写入流。

前缀std：：指出名字cout和edl是定义在名为std的命名空间中的。命名空间可以帮助我们避免不经意的名字定义冲突，和使用的库中有相同名字导致的冲突。

：：是作用域运算符，指出我们要使用定义在std命名空间中的名字cout

\>>：输入运算符，接受istream作为左侧运算对象，接收一个对象作为右侧运算对象。将从指定istream读入数据，存入给定对象。



## 1.3 注释简介

单行注释和对于界定符的注释：//和/* */

注释内每行都应当以一个星号开头：

```
/*
 * 简单主函数
 * 读取两个数
 */
```

注释界定符不能嵌套

单行注释中任何内容都会被忽略，包括嵌套的注释也一样。



## 1.4 控制流

程序设计提供了多种不同的控制流语句，允许我们写出更为复杂的执行路径。

### 1.4.1 while语句

```c++
while(condition){
    statement;
}
```

while语句交替检测condition条件和执行关联语句statement，直到condition为假停止。

++val; 等价于 val = val +1;

### 1.4.2 for语句

while循环体中val变量递增这种情况在循环体中非常普遍，所以c++给出了for语句来简化这种模式的语句。

```c++
for (int val = 1; val <10; val++)
    sum+=val
```

每个for语句包含两部分，循环头循环体。循环头控制循环体执行次数，由初始化语句，循环条件和表达式组成。

**val++是在循环体执行完后执行的**

### 1.4.3 读取数量不定的输入数据

```c++
int sum =0, value =0;
while(std::cin >> value){
    sum +=value;
}
std::cout<<sum<<std::endl;
```

当我峨嵋你使用istream对象作为条件，效果是检测流的状态。如果输入有效那么检测成功；如果输入遇到文件结束符end-of-file，或者遇到无效输入（读入不是一个整数），istream对象状态会变成无效，判断条件编程假。

windows文件结束符是ctrl+z+enter

macos 和 unix是ctrl+d

### 1.4.4 if语句

**这一段都是在强调我们如何使用istream的输入进行自动终止，很有意思**

c++没有标准的格式，只有相同和一致性相似的格式类型。

## 1.5 类简介

如何定义一个数据类型来表示销售数据，我们通过类进行定义。C++最初的一个设计焦点就是如何能保证定义使用上像内置类型一样自然的类类型。

我们发现为了使用标准库设施，我们必须包含相关的头文件。类似的，我们也需要使用头文件来访问为我们自己的应用程序所定义的类。习惯上我们的头文件按照定义的类的名称进行命名.h文件，一般来说编译器不关心头文件名称形式，但是有的IDE对于这个有特定的要求。

### 1.5.1 Sales_item类

Sales_item类设计：

属性：表示一本书的总销售额、售出册数、平均售价

方法：

+ isbn函数返回书本的ISBN书本号码

+ \>> \<<读写Sales item类对象
+ =赋值运算符将一个Sales item对象赋值给另一个Sales item对象
+ +加法运算符将两个Sales item对象相加，两个对象必须表示同一本书，加法结果是一个新的Sales item对象，其ISBN与两个运算对象相同，但是他的总销售额是两个运算对象的对应值的和
+ 使用复合赋值运算符（+=）将一个Sales_item对象加到另一个对象上

**重点概念：类定义了行为**

类的作者定义了类对象可以执行的所有操作：创建对象的时候会发生什么，对于对象进行赋值、加法、输入输出运算的时候会发生什么事情。

这一章我们不需要知道怎么定义这个类，我们只需要知道如何对已经定义好的类进行操作,比如下面这个操作：

```c++
#include <iostream>
#include "Sales_item.h"

int main(){
  Sales_item book;
  std::cin>>book;
  std::cout<<book<<std::endl;
  return 0;
}
```

我们就可以录入书本的编号，售出册数和销售价格

**使用文件重定向**

测试程序需要反复输入销售记录，非常麻烦，可以支持文件重定向，允许我们将标准输入和输出与命名文件关联起来。

```c++
  $ add <infile >outfile
```

**类的成员函数**

Sales_item item1,item2;

item1.isbn() ==  item2.isbn() 成员函数作为类的一部分函数，有时候也叫做方法。

.点运算符表示我们需要”名为item1的对象的isbn成员“

（）调用运算符，里面放置实参列表。



## 1.6 书店程序

需求：从一个文件中读取销售记录，生成每本书的销售报告，显示出售册数、总销售额、平均售价。



## 1.7 本章小结

本章让我们：

+ 能编译、运行简单的C++程序
+ 我们看到了如何定义一个main函数，他是操作系统执行我的程序的入口
+ 如何定义变量
+ 如何输入输出
+ 如何编写if for while语句
+ C++中最基本的特性：类是什么
+ 对于其他人定义的一个类，我们应该如何创建，使用他的对象。



# 第 I 部分 C++基础

任何编程语言都具有一组公共的语法特征，不同语言只有在特征的细节上有一定区别。最基本的特征包括：

+ 整型、字符型等内置类型
+ 变量：用来给对象命名
+ 表达式和语句：用于操纵上述数据类型的具体值
+ if或者while等控制结构，这些结构允许我们有选择地执行一些语句或者重复执行一些语句
+ 函数，用于定义可供随时调用的计算单元

如何进一步补充基本特征：

（1）赋予程序员自定义数据类型的权利

（2）将一些有用的功能封装成库提供给程序员

C++是一种静态数据类型语言，类型检查发生在编译时而不是python一样发生在运行时。编译器必须知道程序中每一个变量对应的数据类型。

C++可以让程序员用简单的基础类型去创造出无数的其他数据类型，这是c++强大的原因。类类型可以让程序员自己创建自己的数据类型。有一些编程语言，类中只能定义数据属性，但是c++的类中我们可以定义数据属性和函数方法两个东西。



# 2 变量和基本类型

数据类型是程序的基础，他告诉我们数据的意义以及我们可以在数据上进行的操作。

## 2.1 基本内置类型

C++定义了一套算数类型和空类型。

### 2.1.1 算数类型

分为两类：整型（包括字符和布尔类型）、浮点型。

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8 bits       |
| Wchar_t     | 宽字符         | 16 bits      |
| Char16_t    | Unicode字符    | 16 bits      |
| Char32_t    | Unicode字符    | 32 bits      |
| short       | 短整型         | 16 bits      |
| int         | 整型           | 16 bits      |
| long        | 长整型         | 32 bits      |
| long long   | 长整型         | 64 bits      |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

**内置类型的机器实现：**

736424 0 0 1 1 0 1 1 0

736425 0 0 0 1 1 0 1 1 

746426 0 1 1 1 0 0 0 1

我们可以说736424的字节or字，对应：00110110 或者 00110110 00011011

bit位：1位二进制位，byte字节：8位二进制位，word字：4或者8字节 对应32或者64位



**带符号类型和无符号类型**

除去布尔型和扩展字符型，其他的整型可以划分为带符号的，无符号的两种。带符号类型可以表示整数、负数或者0，无符号类型只能表示大于等于0的值。

比如 int 有int和unsigned两种

但是char有 char signed char unsigned char三种，只不过char会表示成signed或者unsigned里面的一个，所以实际上只有两种。

### 2.1.2 类型转换

类型所能表示的值的范围决定了转化的过程：

+ 当我们把一个布尔类型的算数值赋值给非布尔类型，初始值是false则结果为0，true结果是1；反过来如果初始值是0则布尔类型得到false，否则是true
+ 当我们把浮点数赋值给整型，只保留小数点前部分；反过来小数部分记为0；如果所占空间超过浮点数容量，精度损失
+ 当我们把一个无符号数赋值给超出他表示范围的值，结果是对于无符号类型表示数值总数取模得到的结果

eg：unsigned char = -1; //假设char占据1字节，c的值是-1 mod 256 = 255

+ 当我们赋值给带符号类型一个超出他表示范围的值，结果是未定义的undefined，此时程序可能继续工作，可能寄了，也可能产生垃圾数据。

eg：signed char c2 = 256 //c2此时是未定义的



**建议：程序要尽量避免依赖于实现环境的行为**

比如我在程序里面写绝对路径，这样的程序是不可移植的。又比如说我们**把int的尺寸看做一个确定不变的已知量（迁移到32位机器上就可能报错了）**，这样的程序也是不可移植的。因为一个程序无法保证在别的编译器下还能够正常运行，甚至已经通过编译的代码再次执行也有可能会出错。这主要是因为一些无法预知的行为，主要是源于编译器无需or不能检测出的错误。

**建议：不要混用带符号类型和不带符号类型**

如果表达式里面既有带符号类型也有不带符号类型，当带符号类型取值为负时就会自动转换成无符号数取模，这样最终的结果就不对了。

### 2.1.3 字面值常量

字面值常量literal对应一种数据类型，字面值常量的形式和值决定了他的数据类型：

20 ：十进制 024 ： 八进制  0x14：十六进制

十进制字面值的类型是int long longlong中尺寸最小最接近的那个（**严格来说十进制字面值不会有负值，因为-42在计算机中其实是存储42然后取负的意思**）

八进制和十六进制字面值的类型是能容纳他的int unsigned int unsigned long long long和unsigned long long立面尺寸最小的。类型short没有对应的字面值。



**字符和字符串字面值**

单引号括号起来的是字符char型字面值；双引号括起来的零个或者多个字符则构成字符串字面值

'a' "Hello world!"

字符串字面值实质上是**常量字符构成的数组**，编译器在每个字符串结尾添加一个空字符'\0'，所以字符串值的实际长度要比他的内容多1。

‘A'：1个字节

"A":2个字节（数组，空字符和A）



**转义序列**

不能直接打印的字符和在C++语言中有特殊含义的字符，这两个是程序员无法直接打印的，需要转义字符。

\n 换行 \t 制表 \a 报警 \b退格 \v纵向制表 \?问号 \"双引号

**指定字面值的类型**

通过添加前缀后缀可以改变整形、浮点型和字符型字面值的默认类型

<img src="/Users/tommyzhou/Library/Application Support/typora-user-images/image-20221102172127622.png" alt="image-20221102172127622" style="zoom:50%;" />

```c++
//宽字符型字面值，类型是wchar_t
 L'a';
 
//utf-8字符串字面值(utf-8用8位编码一个Unicode字符)
 u8"hi!";
 
 //无符号整型字面值，类型为unsigned long long
 42ULL;

//单精度浮点型字面值，类型为float
 1E-3F;

//扩展精度浮点型字面值，类型为long double
 3.14159L；
```

**布尔字面值和指针字面值**

true false nullptr三个



## 2.2 变量

变量是一个具名的，可以养程序操作的存储空间。

### 2.2.1 变量定义

类型说明符，比如：

```c++
int sum =0,value, unit_sold = 0;
std::string book("0-201-34252-X")
```

book通过一个string字面值初始化，string是std库提供的一种可变长的字符序列。

**什么是对象？**

C++中对象和变量基本等价，对象是指一块能够存储数据并具有某种类型的内存空间。



**C++中的初始化和赋值**

很多编程语言中初始化和幅值是一回事儿，但是c++不是，但又很容易让人以为是这样的，比如：

double price = 109.99, discount = price *0.16;

//price先被定义并赋值，随后用于初始化discount

C++的等号=既可以用来赋值，又可以用来初始化，这是由于运算符重载造成的。

**Warning！！初始化不是赋值**

初始化的意义是创建变量时赋予一个初始值，赋值的意思是将对象的当前值擦去，用一个新的值来替代。



**列表初始化**

int unit = 0;

int unit = {0};

int unit{0};

int unit(0);

作为C++11新标准的一部分，花括号来初始化变量得到了全面应用。这种初始化方式叫做列表初始化。

这种初始化的特点是：**如果我们使用列表初始化且初始化值存在丢失信息的风险，编译器会**

eg：

```c++
long double ld = 3.14159265358979
int a{ld}, b = {ld} //错误：转换未执行，因为存在丢失信息的风险
int c（ld）, d = ld //正确，转换执行，且确实丢失了部分值
```

a，b初始化都失败，因为int可能吞不下long double的整数部分 & 肯定会吞不下小数部分。

**默认初始化**

没有赋值的变量的默认值和1、变量类型 2、定义变量的位置有关

定义在任何函数体之外的变量会被初始化成0

定义在函数体内部的内置类型变量不会被初始化，一个没有被初始化的内置类型变量的值是未定义的。此时进行拷贝或者通过其他方式访问这个类会报错。

本质：每个类可以决定初始化对象的方式，是否允许不经过初始化就定义对象也是由类自己定义的。

绝大多数类都支持不需要显式初始化定义对象，比如说string，不赋值会产生一个空字串。

**未初始化变量引发运行鼓掌**

编译器并没有要求检查未初始化变量这类错误，所以可能会产生各种问题。建议初始化每一个内置类型的变量，这样可以保证初始化后的程序安全。

### 2.2.2 变量声明和定义的关系

C++支持分离式编译：允许将程序分割成多个子文件，每个文件可以被独立编译。

如果把程序分割成多个文件，就需要使用另一个文件中定义的变量。

所以c++需要把**声明**和**定义**分开，**声明**让名字被程序认识，一个文件如果想要使用别处定义的名字必须包含对于那个名字的声明。**定义**负责创建和名字关联的实体。

变量声明规定变量的类型和名字，定义还会申请存储空间，也有可能为变量赋一个初始值。

如果想要声明一个变量而非定义他，那么就可以在变量名前添加关键字extern，不要显式初始化变量：
```c++
extern int i;
int j;
```

如果给extern关键字标记的变量赋初始值，那么就抵消了extern的作用：

extern double pi = 3.1415；//定义 不是声明

函数体内部如果试图初始化一个extern标记的变量会引发错误

**一个变量只能被定义一次，但可以被多次声明**

变量的定义只能出现在一个文件中，到了其他文件中必须进行声明，但是不能重复定义。

**关键概念：静态类型**

静态类型的意思是在编译阶段检查类型。之所以要检查类型是因为对象的类型决定了对象所能够参加的运算，如果试图执行类型不支持的运算，那么编译器会报错并且不能生成可执行文件。

程序越为复杂，静态类型检查就越能帮助我们发现问题，然而前提是编译器要知道每个实体对象的类型，这就要求我们在使用某个变量之前进行变量类型声明。

### 2.2.3 标识符

大小写敏感，int a,A;是两个变量。

规范：自定义标识符不能连续出现两个连续的下划线；也不能以下划线紧连大写字符；也不能在定义在函数体外的标识符使用下划线开头

```
__add
_AGJKW
_PATH_DIR
```

**变量命名规范**

+ 标识符要能体现具体函数
+ 变量名一般用小写
+ 用户自定义类大写开头
+ 标识符有多个单词，使用student_loan或者studentLoan两种命名法

### 2.2.4 名字作用域

作用于是程序的一部分，c++通过花括号分割函数作用域。

定义在函数体之外的变量具有全局作用域 global scope，

定义在函数体内的具有块作用域 block scope

嵌套的作用域：一个外层作用域所嵌套的所有作用域中都能访问外层作用域中定义的名字。

**如果函数有可能用到全局变量，则不宜在定义一个同名的局部变量**



## 2.3 复合类型

复合类型是基于其他类型定义的变量：引用和指针就是最常见的两种。

一条声明语句是一个数据类型+一个变量名列表组成的❌

一条声明语句是由一个基本数据类型+紧接着的一个声明符列表组成的✔

每个声明符命名了一个变量并指定该变量是和基本数据类型有关的某种类型。

### 2.3.1 引用

引用reference给对象起了另外一个名字，引用类型引用另一种类型，通过&d形式定义：

```c++
int ival = 1024;
int &refVal = ival; //ival和refval指向同一个地址
int &refVal2; //报错，引用必须被初始化
```

常见的初始化变量时，我们只是把初始值给实例化的对象；但是对于引用，他是将初始值和实例化的对象紧紧绑定在一起。

**引用不是对象，他只是给一个已经存在的对象起了另一个名字**

````c++
refVal = 2;		//把2赋值给refVal指向的对象，就是赋值给了ival
int ii = refVal;//和ii = ival效果一样
````

**引用的定义**

由于引用不是一个对象，所以不能定义引用的引用。

引用只能绑定在对象上，不能和字面值或者某个表达式的计算结果绑定

```c++
int &refVal4 = 2048;//错误的，无法绑定字面值
double dval = 3.14;
int &refVal4 = dval;//错误的，引用初始值必须是int对象
```



### 2.3.2 指针

指针和引用作为两种复合类型，都完成了对于其他对象的间接访问。但是指针和引用又有很多不同。

（1）指针就是一个对象，允许对于指针赋值和拷贝，在生命周期中可以只想几个不同的对象

（2）指针无需赋初始值，在块作用域内定义的指针如果没有初始化那么也拥有一个不确定的值。

```c++
指向int类型的指针：
int *p;
指向double类型的指针：
double *p1;
```

**获取对象的地址**

指针存放的是某个对象的地址，如果想要获得这个地址，使用**取地址符**。

```c++
int ival = 42; //p存放变量ival的地址
int *p = &ival;
```

要记住：**指针指向的是对象的地址，引用不是对象，所以不能定义指向引用的指针。**

```c++
double dval; //创建一个double对象
double *pd = &dval; //保存dval对象的地址，dval是double对象实例
double *pd2 = pd; //pd2和pd都是指向double类型的指针，值是地址。所以直接赋值的意思是pd保存的double对象的地址也分给pd2一份
double **pd3 = &pd;//这才是指向指针的指针（二级指针），pd3保存pd对象的地址，pd是指向double类型的指针对象的实例
```

上面这个地方，非常有趣啊。只要记住：xx（左）保存xx（右）对象地址，，和都是同一类型的指针，右边把保存的地址share给左边。这两句话就能解决大多数指针问题了。

**指针值**

指针的值（地址）对应四种状态：

+ 指向一个对象
+ 指向紧邻对象所占空间的下一个位置
+ 空指针，没有任何对象
+ 无效指针（编译器不会查这个问题，所以后果无法预计）

**利用指针访问对象**

如果指针指向一个对象，允许使用解引用符（*）来访问对象。

```c++
int ival = 42;
int *p = &ival;
cout << *p;

*p = 0; //给ival赋值
cout << ival;
```

**可以发现，\*和&有两重含义，如何区分？**

```c++
int i =42;
int &r = i;
int *p;
p = &i;
*p = i;
int &r2 = *p; 
//*在左边是指针，右边是解引用
//&在左边是引用，右边是取地址符号
```

**空指针**

空指针可以转化成任意其它类型的指针。

需要先声明#include \<cstdlib>,有三种生成空指针的方式：

```c++
int *p1 = NULL; //预处理变量NULL，运行在编译之前
int *p2 = nullptr;
int* p3 = 0;
```

这三种方式都能够生成空指针。NULL：当遇上预处理变量的时候，预处理器会自动将他替换成实际值，所以新标准下建议使用nullptr。

**建议：初始化所有指针**

使用没有经过初始化的指针是引发错误的一大原因。

**赋值和指针**

指针和引用都能提供对于其他对象的间接访问，但是实现方法很不一样，主要是因为引用不是一个对象，指针是的。

```c++
int i = 42;
int *pi = 0;
int *pi2 = &i;
int *pi3;

pi3 = pi2; //pi3 pi2指向i
pi2 = 0;//现在的pi2不指向任何对象了，pi3还是指向i
```

复制改变的永远是灯饰左侧的对象

```c++
pi = &ival;
*pi = 0; //ival变成0
```

**其他指针操作**

如果指针的值是0，那么条件取false

两个同样类型的指针可以通过==和！=来比较他们的值，结果是bool类型的true or false

### 2.3.3 理解复合类型的声明

**变量的定义 = 基本数据类型 + 一组声明符**

同一条定义语句中可能有一个基本数据类型和多个声明符：

```c++
int i = 1024, *p = &i, &r = i;
```

类型修饰符*其实只是声明符的一部分啦。

**定义多个变量**

由于这样写容易产生误导：

```c++
int* p,p1; //p是int指针，p1是int
```

和基本数据类型连在一起写，其实只有第一个是指针。

**指向指针的指针**

就像我们上面2.3.2中阐述的，保存指针地址的指针叫做二级指针，这意味着复合类型是可以进行嵌套的：

```c++
int i = 0;
int *pi = &i; //pi保存i的地址，i是int变量
int *p2 = pi; //p2和pi指向同一个地址
int **p3 = &pi;//p3保存pi的地址，pi是int*指针变量
```

**指向指针的引用**

面对一条比较复杂的指针或者引用的声明语句，从右向左阅读有助于弄清楚他的真实含义。

```c++
int i = 42; 
int *p;
int *&r = p; //从右向左：r是一个引用，他引用的是int*指针p，所以r就是*p
r = &i;
*r = 0;//i赋值为0
```

## 2.4 const限定符

我们希望定义一种变量，值不会被改变。比如用一个变量表示缓冲区大小，这种变量我们很容易进行调整，而且在程序运行过程中不会被改变。我们使用**const**对他进行限定。

```c++
const int bufSize = 512;
bufSize = 2;// 错误：bufSize不能被改变数值
const int k; //错误：const必须被初始化
```

**初始化和const**

对象的类型决定了他上面的操作，const修饰的类型可以完成大多数功能，主要的限制是在const类型对象上进行修改的操作不能进行。

比如const int和int一样可以参与加减乘除，但是不能接收值。

此外，拷贝一个const对象的值生成的新对象不会有const特性（因为他是生成的一个新对象）

**const仅在文件内有效**

在不同的文件中出现同名的const变量其实是定义了多个独立变量。

使用extern在多个需要使用const的文件中声明const可以避免多次定义出现的错误or重复定义问题。

### 2.4.1 const的引用

对于常量的引用（reference to const）和普通引用不同的是，对于常量的引用不能被用于修改他绑定的对象。

```c++
const int ci = 1024;
const int &r1 = ci; //正确的，引用及其引用的对象都是常量
r1 = 42;//错误的
int &r2 = ci;//错误的，试图让一个非常量引用指向一个常量对象
```

常量引用这个简称并不一定代表对字面量进行引用哈。

**初始化和对于const的引用**

2.3.1提到引用的类型必须和所引用的对象类型一致，但是有两种例外。

（1）第一种情况：初始化常量引用时允许用任意表达式作为初始值，只要这个表达式可以转化为引用的类型就可以。

```c++
int i =42;
//const int temp = i;
//const int &r1 = temp
const int &r1 = i; //允许const int&绑定到一个普通的int对象上
const int &r2 = 42; //正确：r2是一个常量引用，普通引用不能绑定字面量
const int &r3 = r1 *2; //正确：r3是一个常量引用
int &r4 = r1 *2; //错误，r4不是常量引用，必须和int绑定
```

（2）所以当一个常量引用绑定到另一个类型上时发生了什么？

```c++
double dval = 3.14;
const int &ri = dval;
其实发生了：
const int temp = dval;
const int &ri = temp;
```

ri绑定了一个临时量对象（编译器创建一个空间来暂存表达式的求值结果）

**对于const的引用可能引用一个并非const的对象**

有意常量引用可以引用其他类型的，所以会出现：

```c++
int i =42;
const int &r1 = i;
```

我们不饿能通过r1来修改i的值，但是我们可以直接给i赋值，这样也让r1发生了改变。

### 2.4.2 指针和const

指向常量的指针不能用于改变所指对象的值。想要得到存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi = 3.14;
double *ptr = &pi;//错误，ptr是普通指针
const double *ptr2 = &pi;//正确
*ptr2 = 42;//错误，不能给常量赋值
```

但还是刚才的例外情况，一个指向常量的指针可以指向非常量对象：

```c++
double dval = 3.14; //dval可以改变
ptr2 = &dval;//赋值正确，但是不能通过ptr2改变dval
```

**指向常量的指针和引用，只是自以为是滴认为自己指向了常量，所以自觉地不去改变所指对象的值**

**const指针**

常量指针：初始化完成后他所指向的地址不能发生改变。

```c++
int errNumb = 0;
int *const curErr = &errNumb;
//从右向左：curErr是一个常量，curErr是一个常量指针，常量指针指向int类型
```

但是注意！指针是常量不代表不能通过指针去修改所指向对象的值

### 2.4.3 顶层const

指针本身是一个对象，它又可以指向另一个对象，所以指针本身是不是常量和所指对象是不是常量就是两个独立的问题。使用**顶层const**表示指针是一个常量；使用**底层const**表示所指对象是一个常量。



### 2.4.4 constexpr和常量表达式

常量表达式是值不会改变并且在编译过程就能得到计算结果的表达式。

```c++
const int max = 20;// yes
const int limit = max+1; //yes
int staff = 27;//no
const int sz = get_size();//no
```

**constexpr变量**

复杂系统中难以分辨一个初始值是不是常量表达式，可以定义一个const变量并且把它的初始值设定为我们认为的某个常量表达式。但是实际使用中，尽管要求如此但是常常发现初始值并非常量表达式的情况。

我们可以将变量声明为constexpr类型，来让编译器验证变量的值是不是一个常量表达式。

```c++
constexpr int mf = 20;//20是常量表达式
constexpr int limit = mf+1;//mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是正确的语句
```

新标准允许使用consexpr函数，简单到编译时就能计算出他的结果，这样constexpr函数就可以初始化constexpr变凉了。

**所以如果你认定变量是一个常量表达式，就声明称constexpr类型**

**字面值类型**

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制，有因为这些类型比较简单，所以称作”字面值类型“。

算术类型、引用和指针都属于字面值类型，自定义类，IO库，string类型不属于字面值类型。

函数体内部定义的变量一般不是存放在固定地址中，所以constexpr指针不能指向这样的变量。定义在所有函数体之外的对象地址固定不变，就能够用来初始化constexpr指针。

允许函数定义一类有效范围超出函数本身的变量。这类变量和定义在函数体之外的变量一样有固定地址，所以constexpr引用可以绑定在这样的变量上，constexpr指针也可以指向这样的变量。（6.1.1节）

**指针和constexpr**

constexpr限定指针只和指针有效，对指针所指的对象无关。

```c++
const int *p = nullptr;//p是一个指向整型常量的指针
constexpr int *q = nullptr;//q是一个指向整数的指针
```

p q完全不同，p是指向常量的指针，q是常量指针（顶级指针）。因此constexpr将他定义的对象变成了顶层const。

```c++
constexpr int *np = nullptr;//np是指向整数的常量指针，值为空
int j = 0;
constexpr int i = 42;//i是整型常量
constexpr const int *p = &i;//p是常量指针，指向整型常量i
constexpr int *p1 = &j;//p1是常量指针，指向整数j
```



## 2.5 处理类型

有些类型太难拼写容易拼错

### 2.5.1 类型别名

类型别名是一个名字同义词，使用typedef

```c++
typedef double wages;//wages是double的同义词
typedef wages base,*p;//base是double的同义词，p是double*的同义词
```

这里的声明符号也可以包含类型修饰，从而从基本数据类型构造出复合类型来。

新标准可以使用别名声明：using

```c++
using SI = Sales_item; //SI是Sales_item的同义词
```

**指针、常量和类型别名**

pstring是char*的别名

```c++
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps;//ps是一个指针，他的对象是指向char的常量指针（二级指针）
```

遇到一条类型别名的声明语句，人们会将别名替换成他本来的样子来理解语句的含义，这是错误的。

```c++
const char *cstr = 0; //是对于const pstring cstr的错误理解
```

**这是错误的！！！**声明语句中使用到了pstring，其基本数据类型是指针。所以const pstring cstr是常量指针；但是改写以后就变成了cstr是指针，指向const char，从顶层指针变成了底层指针。这个地方一定要注意。

### 2.5.2 auto类型说明符

又是做不到声明变量类型，新标准引入auto，可以让编译器帮助我们分析表达式类型，auto可以让编译器通过初始值来推算变量类型。但是显然auto变量必须有初始值。

由于一条声明语句只能有一个基本数据类型，所以该语句中的auto初始基本数据类型必须一样：

```c++
auto i = 0, *p = &i;//正确的，i是int，p是int指针
auto sz = 0, pi = 3.14;//错误的，两个基本数据类型不同
```

**复合类型，常量和auto**

综合起来就变得非常复杂了。p61



## 2.6 自定义数据结构



## 2.7 本章小结





